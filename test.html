<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Collison Animation</title>
    <style>
        canvas {
            padding: 0;
            margin: auto;
            display: block;
        };
    </style>
</head>

<body onload="onShow()">
    <canvas id="canvas" width="1000" height="500" style="background-color: black;"></canvas>

<script>

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    canvas.width = window.innerWidth; // set the canvas to span the size of the inner bowser window
    canvas.height = window.innerHeight;

    //internal canvas resolution
    const canvas_width = canvas.width; // get canvas resolution as constant variable 
    const canvas_height = canvas.height;

    const canvas_centrex = canvas_width/2;
    const canvas_centrey = canvas_height/2;

    //window size (excluding toolbar etc.)
    const window_width = window.innerWidth; // get window size as constant variable, though better to refer to canvas resolution
    const window_height = window.innerHeight;

    const window_centrex = window_width/2;
    const window_centrey = window_height/2;

    // circles 
    var circle_xpos_window = canvas_width/2;
    var circle_ypos_window = canvas_height/2;

    var circle_size = 20; // this is probably deprecated, will remove soon, adjust size as visual degrees if necessary
    var circle_colour = "#808080";
    // var circle_speed = 1; currently undefined

    var fixation_size = 40; // define youself as visual degrees are not given in previous publications  
    var fixation_colour = "#ff0000";
    var fixation_cross_speed = 5; 

    // everything visual degrees 

    const circle_size_vs = 1.5 // size of circles in visual degrees
    const fixation_offset_vs = 5 // visual degrees from centre

    const distance_from_screen = 60 // distance from screen in cm

    const screen_vs_ratio_horizontal = 1920/509.76 // ratio of pixels per mm, depends on screen, needs to be checked manually 
    const screen_vs_ratio_vertical = 1080/286.74 // ratio of pixels per mm

    const circle_size_radians = (circle_size_vs)*(Math.PI/180) // converting vs to radians
    const fixation_offset_radians = (fixation_offset_vs)*(Math.PI/180) // converting the vs into radians because code does not like degrees

    const circle_screen_size = Math.tan(circle_size_radians)*distance_from_screen*10 // actual circle size in mm
    const fixation_offset_screen_size = Math.tan(fixation_offset_radians)*distance_from_screen*10 // actual fixation cross offset in mm

    const circle_size_in_pixel = Math.round(circle_screen_size*screen_vs_ratio_horizontal, 2) // note that the disc needs to be defined along the X and Y axis but as we are displaying a circle both ratios would return the same size
    const fixation_offset_in_pixel = Math.round(fixation_offset_screen_size*screen_vs_ratio_horizontal, 2)
 
    var circle_size = circle_size_in_pixel/2 // as JS uses radius but we want it be the diameter
    var fixation_offset = fixation_offset_in_pixel

    // fixation cross 
    if (Math.floor(Math.random() * 2) == 0) { // randomise initial fixation location
        var initial_fixation_location = "left"        
    } else {
        var initial_fixation_location = "right"
    };

    var fixation_location = initial_fixation_location;
    
    let fixation_xpos;
    if (fixation_location == "left") {
        fixation_xpos = (canvas_centrex) - fixation_offset;
    } else {
        fixation_xpos = (canvas_centrex) + fixation_offset;
    };

    var fixation_ypos = canvas_centrey;

    var phase = "instructions";

    //development functions (check all false when running experiment) -------------------------------------------------

    const assist_centre = false; // shows where the centre is
    const assist_grid = false; // shows a grid of the points between which the circles should move
    const assist_text = false; // labels the circles to be able to better differentiate them

    //-----------------------------------------------------------------------------------------------------------------

    function onShow() { //define variables here

        const Circles = new CollisionCircles(circle_xpos_window, circle_ypos_window, circle_size, circle_colour);
        const FixationCross1 = new FixationCross(fixation_xpos, fixation_ypos, fixation_size, fixation_colour); // think about adding speed here

        
        this.objects = Circles;
        this.FixationCross = FixationCross1;
        window.requestAnimationFrame(this.drawScene);
    };

    this.drawScene = function() { //play the animation here   
        ctx.clearRect(0, 0, canvas.width, canvas.height); 

        if(phase == "instructions") {
            main_instructions()

            onkeydown = function() {
                if (event.key === " ") {
                    console.log("yes")
                    phase = "training"
                }
            };
        };

        if (phase == "training") {
            this.FixationCross.draw(canvas)

            
        };

        

        // development functions (leave as is) ---------------------------------------------------------------------

        if (assist_centre == true) {
            ctx.beginPath();
            ctx.fillStyle = "#000000";
            ctx.arc(canvas.width/2, canvas.height/2, 10, 0, 2 * Math.PI);
            ctx.fill();
        };

        if(assist_grid == true) {
            ctx.beginPath();
            ctx.fillStyle = "green";
            ctx.arc(objects.startx, objects.starty, 10, 0, 2 * Math.PI);
            ctx.fill();

            ctx.beginPath();
            ctx.fillStyle = "#ff0000";
            ctx.arc(objects.centrex, objects.centrey, 10, 0, 2 * Math.PI);
            ctx.fill();

            ctx.beginPath();
            ctx.fillStyle = "orange";
            ctx.arc(objects.endx, objects.endy, 10, 0, 2 * Math.PI);
            ctx.fill();
        };

        if(assist_text == true) {
            ctx.fillStyle = "green";
            ctx.fillText("1", objects.circle1x, objects.circle1y);
            ctx.fillStyle = "orange";
            ctx.fillText("2", objects.circle2x, objects.circle2y);
        };

        window.requestAnimationFrame(this.drawScene)

    };

    // Functions below ---------------------------------------------------------------------------------

    function CollisionCircles(xpos, ypos, size, colour) {
        this.xpos = xpos; //should be relative to fixation cross
        this.ypos = ypos;
        this.size = size;
        this.colour = colour;

        this.distance = 100; //should probably be based on visual degrees

        this.angle = 0; 
        this.radian = this.angle*(Math.PI/180);

        this.overlap = 0;

        this.phase = "start";

        this.centrex = this.xpos;
        this.centrey = this.ypos;

        this.startx = this.centrex - Math.cos(this.radian)*this.distance;
        this.starty = this.centrey + Math.sin(this.radian)*this.distance;

        this.endx = this.centrex + Math.cos(this.radian)*this.distance;
        this.endy = this.centrey - Math.sin(this.radian)*this.distance;

        this.circle1x = this.startx;
        this.circle1y = this.starty;

        this.circle2x = this.centrex - Math.cos(this.radian)*(this.overlap); //multiply by size of the circle
        this.circle2y = this.centrey + Math.sin(this.radian)*(this.overlap);
        
        this.draw = function(canvas) {
            ctx.beginPath();
            ctx.fillStyle = this.colour;
            ctx.arc(this.circle1x, this.circle1y, this.size, 0, 2 * Math.PI);
            ctx.fill();

            ctx.beginPath();
            ctx.fillStyle = this.colour;
            ctx.arc(this.circle2x, this.circle2y, this.size, 0, 2 * Math.PI);
            ctx.fill();
        };

        this.movecircle1tocentre = function() {

            var speed = 1

            var distanceX = Math.abs(this.circle1x - this.centrex);
            var distanceY = Math.abs(this.circle1y - this.centrey);

            if (distanceX > 0.1 || distanceY > 0.1) {
                this.circle1x = this.circle1x + Math.cos(this.radian)*speed;
                this.circle1y = this.circle1y - Math.sin(this.radian)*speed;    
            } else {
                this.phase = "centre";
            };
        };

        this.movecircle2toend = function() {

            var speed = 1

            var distanceX = Math.abs(this.circle2x - this.endx)
            var overX = this.size*Math.abs(Math.cos(this.radian))*(this.overlap)
            var distanceY = Math.abs(this.circle2y - this.endy) 
            var overY = this.size*Math.abs(Math.sin(this.radian))*(this.overlap)

            if(distanceX > (0.1 + overX) || distanceY > (0.1 + overY)) {
                this.circle2x = this.circle2x + Math.cos(this.radian)*speed;
                this.circle2y = this.circle2y - Math.sin(this.radian)*speed;
            } else {
                this.phase = "end";
            };
        };

        this.reset = function(new_angle, new_overlap) {

            this.angle = new_angle; 
            this.radian = this.angle*(Math.PI/180);

            this.overlap = new_overlap;

            this.centrex = this.xpos; //might not need to change
            this.centrey = this.ypos;

            this.startx = this.centrex - Math.cos(this.radian)*this.distance;
            this.starty = this.centrey + Math.sin(this.radian)*this.distance;

            this.endx = this.centrex + Math.cos(this.radian)*this.distance;
            this.endy = this.centrey - Math.sin(this.radian)*this.distance;

            this.circle1x = this.startx;
            this.circle1y = this.starty;

            this.circle2x = this.centrex - Math.cos(this.radian)*(this.overlap); //multiply by size of the circle
            this.circle2y = this.centrey + Math.sin(this.radian)*(this.overlap);

            this.phase = "start";
        };

        this.playanimation = function() {
            
            if(this.phase == "start") {
                this.movecircle1tocentre();
            };
            if(this.phase == "centre") {
                this.movecircle2toend();
            };
            if(this.phase == "end") {
                this.reset(0, 0);
            };
        };
    };

    function FixationCross(xpos, ypos, size, colour) {
        this.xpos = xpos;
        this.ypos = ypos;
        this.size = size;
        this.colour = colour;

        this.xpos_left = canvas_centrex - fixation_offset;
        this.xpos_right = canvas_centrex + fixation_offset;

        this.rec1sizex = this.size; // defines the sizes, needs to be done via two rectangles, hence they have mirrored dimensions
        this.rec1sizey = this.size/4;
        this.rec2sizex = this.size/4;
        this.rec2sizey = this.size;

        this.rec1x_left = this.xpos_left - this.rec1sizex/2; // pre-define locations to change it easier later
        this.rec1x_right = this.xpos_right - this.rec1sizex/2;
        this.rec2x_left = this.xpos_left - this.rec2sizex/2;
        this.rec2x_right = this.xpos_right - this.rec2sizex/2;

        if (initial_fixation_location == "left") { //decide initial location based on randomised left/right appearance 
            this.rec1x = this.rec1x_left;
            this.rec2x = this.rec2x_left;
        } else {
            this.rec1x = this.rec1x_right;
            this.rec2x = this.rec2x_right;
        }

        this.rec1y = this.ypos - this.rec1sizey/2; // in this version it never changes 
        this.rec2y = this.ypos - this.rec2sizey/2;


        this.draw = function(canvas) {
            ctx.fillStyle = this.colour;
            ctx.fillRect(this.rec1x, this.rec1y, this.rec1sizex, this.rec1sizey);
            ctx.fillRect(this.rec2x, this.rec2y, this.rec2sizex, this.rec2sizey);
        };

        this.move = function(current_location, new_location, speed) {

            var speed = speed; //at the moment in pixels
            
            if(new_location == "right") {
                if(this.rec1x < this.rec1x_right) { // defined location here via rec1 but can also be defined via rec2, as they move simultaneously does not matter
                    this.rec1x = this.rec1x + speed
                    this.rec2x = this.rec2x + speed
                } else {
                this.rec1x = this.rec1x_right;
                this.rec2x = this.rec2x_right;
                }
            }

            if(new_location == "left") {
                if(this.rec1x > this.rec1x_left) {
                    this.rec1x = this.rec1x - speed
                    this.rec2x = this.rec2x - speed
                } else {
                this.rec1x = this.rec1x_left;
                this.rec2x = this.rec2x_left;
                }
            }
        };
    };





// all instructions go here ---------------------------------------------------------------------------------------------------------

function main_instructions() {
    ctx.font = '30px Arial';
    ctx.fillStyle = "white";

    // Draw filled text
    ctx.fillText("test", canvas_centrex, canvas_centrey);

    
}
</script>
</body>
</html>