<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collison Animation</title>
    <style>
        canvas {
            padding: 0;
            margin: auto;
            display: block;
        }

        ;
    </style>
</head>

<body onload="onShow()">
    <canvas id="canvas" width="1000" height="500" style="background-color: black;"></canvas>

    <script>

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        canvas.width = window.innerWidth; // set the canvas to span the size of the inner bowser window
        canvas.height = window.innerHeight;

        //internal canvas resolution
        const canvas_width = canvas.width; // get canvas resolution as constant variable 
        const canvas_height = canvas.height;

        const canvas_centrex = canvas_width / 2;
        const canvas_centrey = canvas_height / 2;

        // circles 
        var circle_xpos_window = canvas_width / 2;
        var circle_ypos_window = canvas_height / 2;

        var circle_size = 20; // this is probably deprecated, will remove soon, adjust size as visual degrees if necessary
        var circle_colour = "#808080";
        var circles_speed = 10;
        var circles_distance = 100; // just a random distance atm

        var fixation_size = 40; // define youself as visual degrees are not given in previous publications  
        var fixation_colour = "#ff0000";
        var fixation_speed = 5;

        // everything visual degrees 

        const circle_size_vs = 1.5 // size of circles in visual degrees
        const fixation_offset_vs = 5 // visual degrees from centre

        const distance_from_screen = 60 // distance from screen in cm

        const screen_vs_ratio_horizontal = 1920 / 509.76 // ratio of pixels per mm, depends on screen, needs to be checked manually 
        const screen_vs_ratio_vertical = 1080 / 286.74 // ratio of pixels per mm

        const circle_size_radians = (circle_size_vs) * (Math.PI / 180) // converting vs to radians
        const fixation_offset_radians = (fixation_offset_vs) * (Math.PI / 180) // converting the vs into radians because code does not like degrees

        const circle_screen_size = Math.tan(circle_size_radians) * distance_from_screen * 10 // actual circle size in mm
        const fixation_offset_screen_size = Math.tan(fixation_offset_radians) * distance_from_screen * 10 // actual fixation cross offset in mm

        const circle_size_in_pixel = Math.round(circle_screen_size * screen_vs_ratio_horizontal, 2) // note that the disc needs to be defined along the X and Y axis but as we are displaying a circle both ratios would return the same size
        const fixation_offset_in_pixel = Math.round(fixation_offset_screen_size * screen_vs_ratio_horizontal, 2)

        var circle_size = circle_size_in_pixel / 2 // as JS uses radius but we want it be the diameter
        var fixation_offset = fixation_offset_in_pixel

        // fixation cross 
        if (Math.floor(Math.random() * 2) == 0) { // randomise initial fixation location
            var initial_fixation_location = "left"
        } else {
            var initial_fixation_location = "right"
        };

        var phase = "test"; //phase to run, set to start for real experiment

        const block_size = 18; //traditionally a block should consist of 18 trials, 9 left and 9 right
        const n_blocks = 10; //in direct replications there should be 10 trials
        const overlap_increments = 0.125; //increments of overlap (overlaps ranges between 0 and 1)

        const trials_pre = 180;
        const trials_adaptation = 640;
        const trials_post = 180;

        //generate trials here
        const angles_pre = genAngles(trials_pre);
        const angles_adaptation = genAngles(trials_adaptation);
        const angles_post = genAngles(trials_post);

        const dataStructurePractice = compileTrialStructure(overlap_increments, 1, block_size) //one block for the practice trials only 
        const dataStructurePre = compileTrialStructure(overlap_increments, n_blocks, block_size)
        const dataStructurePost = compileTrialStructure(overlap_increments, n_blocks, block_size) //repeat rather than copy to ensure randomisation

        console.log(dataStructurePre)


        //development functions (check all false when running experiment) -------------------------------------------------

        const assist_centre = false; // shows where the centre is
        const assist_grid = false; // shows a grid of the points between which the circles should move
        const assist_text = false; // labels the circles to be able to better differentiate them

        //-----------------------------------------------------------------------------------------------------------------

        function onShow() { //define variables here

            const Circles1 = new CollisionCircles(circle_size, circle_colour, fixation_offset, circles_distance, circles_speed);
            const FixationCross1 = new FixationCross(canvas_centrex, canvas_centrey, fixation_size, fixation_colour, fixation_offset, initial_fixation_location, fixation_speed); // think about adding speed here
            const Response1 = new ResponseRequest()

            this.Circles = Circles1;
            this.FixationCross = FixationCross1;
            this.Response = Response1;
            window.requestAnimationFrame(this.drawScene);
        };

        this.drawScene = function () { //play the animation here   
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (phase == "start") {
                instructions("Press SPACE when you are ready to begin the experiment."); //add the text in quotation marks or alternatively via a link to a separate txt file

                onkeydown = () => {
                    if (event.key === " ") {
                        phase = "main instructions"
                    };
                };
            };

            if (phase == "main instructions") { //might want to add a red fixation cross again here as an example but not included yet, there are now also plenty of examples which may make that redundant
                instructions("This is where the main instructions go."); //add the text in quotation marks or alternatively via a link to a separate txt file
                instructions_continue(); // this is a fixed set of instructions on which key to press to continue displayed at the bottom of the screen
                onkeydown = () => {
                    console.log(1)
                    if (event.key === " ") {
                        phase = "training"
                    } else if (event.key === "d") {
                        this.Circles.draw();
                        this.Circles.playanimation(canvas_centrex, 0, 45);
                    } else {
                        this.Circles.draw();
                        this.Circles.playanimation(canvas_centrex, 1, 45);
                    }
                };

            };

            if (phase == "training") {
                instructions("Training tasks go here.")
                instructions_continue();

                onkeydown = () => {
                    if (event.key === " ") {
                        phase = "instructions pre"
                    };
                };
            };

            if (phase == "instructions pre") {
                instructions("Instructions for the pre-daptation phase.")
                instructions_continue();

                onkeydown = () => {
                    if (event.key === " ") {
                        phase = "phase pre"
                    };
                };
            };

            if (phase == "phase pre") {

                while (this.Circles.trial_number < trials_pre + 1) { //need to add 1 so all animations are completed    
                    console.log(this.Circles.trial_number)
                    this.FixationCross.draw()
                    this.Circles.draw()
                    this.Circles.playanimation(this.FixationCross.xpos, 0, getRandomIntInclusive(0, 360)) // randomised at the moment for testing
                };
            };

            if (phase == "adaptation") {
                // move fixation cross to opposite fixation location
                if (this.FixationCross.has_moved == false) {
                    this.FixationCross.draw();
                    this.FixationCross.move();
                };

                if (this.FixationCross.has_moved == true) {
                    this.FixationCross.draw();
                    this.Circles.draw();
                    this.Circles.playanimation(this.FixationCross.rec1x, 0, getRandomIntInclusive(0, 360))

                }

                // repeat movement x number of times 


            }
            

            if (phase == "test") {
                this.FixationCross.draw();
                if (!this.FixationCross.has_moved) {
                    this.FixationCross.move();
                } else {

                    if (this.Circles.trial_number < angles_pre.length) {
                        if (!this.Circles.repositioned) {

                            var trialSettings = dataStructurePre[this.Circles.trial_number];

                            this.Circles.position(this.FixationCross.rec1x, trialSettings["location"], trialSettings["overlap"], angles_pre[this.Circles.trial_number]);
                        } else {
                            this.Circles.playanimation()
                        }
                    } else {
                        phase = "adaptation";
                        this.Circles.trial_number = 0;

                    }
                }
            }


            // development functions (leave as is) ---------------------------------------------------------------------

            if (assist_centre == true) { // might not show the centre perfectly as needs to account for radius/diameter affecting x/y, is only a rough guide
                ctx.beginPath();
                ctx.fillStyle = "white";
                ctx.arc(canvas_centrex, canvas_centrey, 10, 0, 2 * Math.PI);
                ctx.fill();
            };

            if (assist_grid == true) {
                ctx.beginPath();
                ctx.fillStyle = "green";
                ctx.arc(Circles.startx, Circles.starty, 10, 0, 2 * Math.PI);
                ctx.fill();

                ctx.beginPath();
                ctx.fillStyle = "#ff0000";
                ctx.arc(Circles.centrex, Circles.centrey, 10, 0, 2 * Math.PI);
                ctx.fill();

                ctx.beginPath();
                ctx.fillStyle = "orange";
                ctx.arc(Circles.endx, Circles.endy, 10, 0, 2 * Math.PI);
                ctx.fill();
            };

            if (assist_text == true) {
                ctx.fillStyle = "green";
                ctx.fillText("1", Circles.circle1x, Circles.circle1y);
                ctx.fillStyle = "orange";
                ctx.fillText("2", Circles.circle2x, Circles.circle2y);
            };

            window.requestAnimationFrame(this.drawScene)

        };

        // Functions below ---------------------------------------------------------------------------------

        function CollisionCircles(size, colour, offset, distance, speed) {
            this.size = size;
            this.colour = colour;
            this.offset = offset;
            this.distance = distance; // distance between circles, currently in pixels
            this.speed = speed;

            this.phase = "position"; // start with requiering positioning
            this.repositioned = false;

            this.trial_number = 0; // counter to keep track of trials

            this.position = function (fixationxpos, fixationRelativeLocation, overlap, angle) {

                this.radian = angle * (Math.PI / 180); // conver the angle to radians because JS prefers radians
                this.overlap = overlap;

                if (fixationRelativeLocation === "left") { // set location relative to either the left or right of the fixation cross
                    this.centrex = fixationxpos - this.offset;
                } else {
                    this.centrex = fixationxpos + this.offset;
                }

                this.centrey = canvas_centrey; // does not change

                this.startx = this.centrex - Math.cos(this.radian) * this.distance; // start and end are relative to the collision centre so only the centre needs to be changed
                this.starty = this.centrey + Math.sin(this.radian) * this.distance;

                this.endx = this.centrex + Math.cos(this.radian) * this.distance;
                this.endy = this.centrey - Math.sin(this.radian) * this.distance;

                this.circle1x = this.startx - Math.cos(this.radian) * (this.size * 2); // set initial location for the first circle
                this.circle1y = this.starty + Math.sin(this.radian) * (this.size * 2);

                this.circle2x = this.centrex - Math.cos(this.radian) * (this.overlap) * (this.size * 2); // set initial location of the second circle
                this.circle2y = this.centrey + Math.sin(this.radian) * (this.overlap) * (this.size * 2);

                this.trial_number++; // increase the trial number every time a new collision is run

                this.repositioned = true;
                this.phase = "start";
            };

            this.draw = function () {
                ctx.beginPath();
                ctx.fillStyle = this.colour;
                ctx.arc(this.circle1x, this.circle1y, this.size, 0, 2 * Math.PI);
                ctx.fill();

                ctx.beginPath();
                ctx.fillStyle = this.colour;
                ctx.arc(this.circle2x, this.circle2y, this.size, 0, 2 * Math.PI);
                ctx.fill();
            };

            this.movecircle1tocentre = function () {

                var distanceX = Math.abs(this.circle1x - (this.centrex - Math.cos(this.radian) * (this.size * 2)));
                var distanceY = Math.abs(this.circle1y - (this.centrey + Math.sin(this.radian) * (this.size * 2)));

                if (distanceX > 0.9 || distanceY > 0.9) { // still need to find a fix for this
                    this.circle1x = this.circle1x + Math.cos(this.radian) * this.speed;
                    this.circle1y = this.circle1y - Math.sin(this.radian) * this.speed;
                } else {
                    this.phase = "centre";
                };
            };

            this.movecircle2toend = function () {

                var distanceX = Math.abs(this.circle2x - (this.endx - (Math.cos(this.radian)) * (this.size * 2) * (this.overlap)));
                var distanceY = Math.abs(this.circle2y - (this.endy + (Math.sin(this.radian)) * (this.size * 2) * (this.overlap)));

                if (distanceX > 0.9 || distanceY > 0.9) {
                    this.circle2x = this.circle2x + Math.cos(this.radian) * this.speed;
                    this.circle2y = this.circle2y - Math.sin(this.radian) * this.speed;
                } else {
                    this.phase = "end";
                };
            };

            this.reset = function () {
                this.repositioned = false;
                this.phase = "position";
            };

            this.playanimation = function () {

                this.draw()

                if (this.phase == "start") {
                    this.movecircle1tocentre();
                };
                if (this.phase == "centre") {
                    this.movecircle2toend();
                };
                if (this.phase == "end") {
                    this.reset();
                };
            };
        };

        function FixationCross(xpos, ypos, size, colour, offset, initialLocation, speed) {

            this.xpos = xpos; // based on canvas centre 
            this.ypos = ypos;

            this.offset = offset;
            this.initialLocation = initialLocation;

            this.size = size;
            this.colour = colour;
            this.speed = speed;

            this.rec1sizex = this.size; // define rectangle sizes to draw a cross
            this.rec1sizey = this.size / 4;

            this.rec2sizex = this.size / 4;
            this.rec2sizey = this.size;

            this.xpos_left = this.xpos - this.offset; // define relative location on screen
            this.xpos_right = this.xpos + this.offset;

            this.rec1x_left = this.xpos_left - this.rec1sizex / 2; // centre rectangles, pre-define locations for ease
            this.rec1x_right = this.xpos_right - this.rec1sizex / 2;

            this.rec2x_left = this.xpos_left - this.rec2sizex / 2;
            this.rec2x_right = this.xpos_right - this.rec2sizex / 2;

            this.rec1y = this.ypos - this.rec1sizey / 2; // centre rectangles, y-level never changes 
            this.rec2y = this.ypos - this.rec2sizey / 2;

            if (this.initialLocation == "left") { // set  initial appearance based on earlier randomisation
                this.rec1x = this.rec1x_left;
                this.rec2x = this.rec2x_left;
            } else {
                this.rec1x = this.rec1x_right;
                this.rec2x = this.rec2x_right;
            };

            this.current_location = this.initialLocation;
            this.has_moved = false;

            this.draw = function (canvas) {
                ctx.fillStyle = this.colour;
                ctx.fillRect(this.rec1x, this.rec1y, this.rec1sizex, this.rec1sizey);
                ctx.fillRect(this.rec2x, this.rec2y, this.rec2sizex, this.rec2sizey);
            };

            this.move = function () {

                if (!this.has_moved) {
                    if (this.current_location == "left") {
                        if (this.rec1x < this.rec1x_right) { // defined location here via rec1 but can also be defined via rec2, as they move simultaneously does not matter
                            this.rec1x = this.rec1x + this.speed
                            this.rec2x = this.rec2x + this.speed
                        } else {
                            this.rec1x = this.rec1x_right;
                            this.rec2x = this.rec2x_right;
                            this.has_moved = true;
                            this.current_location = "right";
                        };
                    } else {
                        if (this.rec1x > this.rec1x_left) {
                            this.rec1x = this.rec1x - this.speed
                            this.rec2x = this.rec2x - this.speed
                        } else {
                            this.rec1x = this.rec1x_left;
                            this.rec2x = this.rec2x_left;
                            this.has_moved = true;
                            this.current_location = "left";
                        };
                    };
                }
            };
        };

        function ResponseRequest() {

            this.text = "Please rate the event.";

            this.xpos = canvas_centrex; // does not change as we want it centred
            this.ypos = canvas_centrey - canvas_height * 0.1; // adjusted to be slightly higher than the fixation cross to not obstruct the view

            this.response_list = []

            this.display = function () {
                ctx.font = "30px Arial"; //currently uses the same font and colour as for instructions 
                ctx.fillStyle = "white";

                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                ctx.fillText(this.text, this.xpos, this.ypos);
            };

            this.awaitresponse = function (trial_parameters) {

                this.display();

                onkeydown = () => {
                    if (event.key === "d") {
                        this.response_list.push("launch");
                    };
                    if (event.key === "k") {
                        this.response_list.push("pass");
                    };
                }
            }

        };




        // all instructions go here ---------------------------------------------------------------------------------------------------------

        var text_font = "30px Arial"; // text font and colour for all text Circles
        var text_colour = "white";
        var text_padding = 200; // size of the padding to the left and right side of text boxes (assuming text boxes are centred)
        var text_height = 40; // height of text line breaks

        // Function for wrapping text, courtesy of: https://fjolt.com/article/html-canvas-how-to-wrap-text
        // @description: wrapText wraps HTML canvas text onto a canvas of fixed width
        // @param ctx - the context for the canvas we want to wrap text on
        // @param text - the text we want to wrap.
        // @param x - the X starting point of the text on the canvas.
        // @param y - the Y starting point of the text on the canvas.
        // @param maxWidth - the width at which we want line breaks to begin - i.e. the maximum width of the canvas.
        // @param lineHeight - the height of each line, so we can space them below each other.
        // @returns an array of [ lineText, x, y ] for all lines
        const wrapText = function (ctx, text, x, y, maxWidth, lineHeight) {
            // First, start by splitting all of our text into words, but splitting it into an array split by spaces
            let words = text.split(' ');
            let line = ''; // This will store the text of the current line
            let testLine = ''; // This will store the text when we add a word, to test if it's too long
            let lineArray = []; // This is an array of lines, which the function will return

            // Lets iterate over each word
            for (var n = 0; n < words.length; n++) {
                // Create a test line, and measure it..
                testLine += `${words[n]} `;
                let metrics = ctx.measureText(testLine);
                let testWidth = metrics.width;
                // If the width of this test line is more than the max width
                if (testWidth > maxWidth && n > 0) {
                    // Then the line is finished, push the current line into "lineArray"
                    lineArray.push([line, x, y]);
                    // Increase the line height, so a new line is started
                    y += lineHeight;
                    // Update line and test line to use this word as the first word on the next line
                    line = `${words[n]} `;
                    testLine = `${words[n]} `;
                }
                else {
                    // If the test line is still less than the max width, then add the word to the current line
                    line += `${words[n]} `;
                }
                // If we never reach the full max width, then there is only one line.. so push it into the lineArray so we return something
                if (n === words.length - 1) {
                    lineArray.push([line, x, y]);
                }
            }
            // Return the line array
            return lineArray;
        };

        // note, might be worthwhile adding an option to specify whether text should be centred or starting from the top for when instructions are very long
        function instructions(txt) {

            this.text = txt;

            ctx.font = text_font;
            ctx.fillStyle = text_colour;

            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // we pass in ctx, text, x, y, maxWidth, lineHeight to wrapText()
            let wrappedText = wrapText(ctx, this.text, canvas_centrex, canvas_centrey, canvas_width - text_padding, text_height);

            wrappedText.forEach(function (item) {
                // item[0] is the text
                // item[1] is the x coordinate to fill the text at
                // item[2] is the y coordinate to fill the text at
                ctx.fillText(item[0], item[1], item[2]);
            });
        };

        function instructions_continue() { // fixed instructions to display a continue message at the bottom of the screen

            this.text = "Press SPACE to continue.";

            ctx.font = text_font;
            ctx.fillStyle = text_colour;

            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            ctx.fillText(this.text, canvas_centrex, canvas_height - text_padding);
        };

        function getRandomIntInclusive(min, max) {
            const minCeiled = Math.ceil(min);
            const maxFloored = Math.floor(max);
            return Math.floor(Math.random() * (maxFloored - minCeiled + 1) + minCeiled);
        };

        //functions for creating trials

        function genAngles(n_angles) { //generates of semi-random list of angles with as little repetition as possible 
            var angles = [];

            var sets_to_run = Math.floor(n_angles / 360);
            var remainder = n_angles - (360 * sets_to_run);


            while (angles.length < remainder) {
                var angle = getRandomIntInclusive(0, 360);
                if (!(angle in angles)) {
                    angles.push(angle);
                };
            };

            if (sets_to_run > 0) {
                for (let sets = 0; sets < sets_to_run; sets++) {
                    var set = angles360();
                    for (let items = 0; items < set.length; items++) {
                        angles.push(set[items]);
                    };
                };
            };
            return angles;
        };

        function angles360() { //generates a random, non-repetative list of 360 angles
            var angles = [];
            while (angles.length < 360) {
                var angle = getRandomIntInclusive(0, 360);
                if (!(angle in angles)) {
                    angles.push(angle);
                };
            };
            return angles;
        };

        function generateRangeOverlap(increments) { //generate a range of overlap
            let sequence = [0];
            let n = 1 / increments;
            for (let i = 0; i < n; i++) {
                sequence.push(sequence[sequence.length - 1] + increments);
            }
            return sequence;
        };

        function generateRangeLocation(blockSize) {
            if (blockSize % 2 !== 0) {
                return "The block size is not even so cannot run the experiment!";
            };

            let positions = [];
            while (positions.length < blockSize) {
                if (positions.length < blockSize / 2) {
                    positions.push("left");
                } else {
                    positions.push("right");
                };
            };
            return positions;
        };

        function compileTrialStructure(increments, nBlocks, blockSize) {
            var trialDict = {};

            for (let n = 0; n < nBlocks; n++) { //repeat the following for each block of trials
                var positions = generateRangeLocation(blockSize);
                var rangeOverlapLeft = generateRangeOverlap(increments);
                var rangeOverlapRight = generateRangeOverlap(increments);

                for (let i = 0 + (((1 / increments + 1) * 2) * n); i < blockSize + (((1 / increments + 1) * 2) * n); i++) {

                    var locationIndex = Math.floor(Math.random() * positions.length);
                    var location = positions[locationIndex];
                    positions.splice(locationIndex, 1);

                    if (location === "left") {
                        var overlapIndex = Math.floor(Math.random() * rangeOverlapLeft.length);
                        var overlap = rangeOverlapLeft[overlapIndex];
                        rangeOverlapLeft.splice(overlapIndex, 1);
                    };

                    if (location === "right") {
                        var overlapIndex = Math.floor(Math.random() * rangeOverlapRight.length);
                        var overlap = rangeOverlapRight[overlapIndex];
                        rangeOverlapRight.splice(overlapIndex, 1);
                    };

                    trialDict[i] = { overlap: overlap, location: location };
                };
            };

            return trialDict;
        };



    </script>
</body>

</html>